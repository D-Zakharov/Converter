# Converter
>>> Веб-сервис, который получает на вход html (потенциально очень большой), конвертирует в pdf (используя Puppeteer Sharp) и возвращает его. Требуется отказоустойчивость: клиент должен получить pdf, даже если в промежутке между получением html и возвратом pdf IIS был перезагружен.
>>> Сервис должен быть масштабируемым, чтобы при необходимости можно было расширить инфраструктуру без необходимости менять код.


Комментарии по требованиям и подходу к их реализации.

---------------------------------------
Раз входящие файлы могут быть настолько большими, что их конвертация займет много времени, а также есть требование по отказоустойчивости (IIS может быть перезагружен), это означает, что взаимодействие между клиентом и сервисом должно быть асинхронным. Клиент получает подтверждение, что сервис принял файл, после чего периодически уточняет, не завершилась ли конвертация. Кроме того, есть требование по масштабируемости. Наиболее очевидным вариантом видится использование очереди, в которую будут помещаться входящие файлы. Можно увеличивать как кол-во обработчиков очереди, так и кол-во сервисов, которые общаются с клиентом (и спрятать последние за балансер). Также в appsettings можно задать значение для ConsumerDispatchConcurrency (если не задано, то используется 1), это позволит распараллелить обработку очереди в рамках одного сервиса. Суммарно это всё позволит реализовать требование простоты масштабируемости. А поскольку применяется асинхронный подход с ключом идемпотентности, не имеет значения, на какой из экземпляров придет html файл, и с какого из экземпляров затребуют pdf.
---------------------------------------

В качестве очереди используется RabbitMQ. Обработчиком выступает worker service. Для хранения контента используется временное хранилище. Html удаляются после успешной конвертации. В данной реализации я не усложнял, оба хранилища представляют собой папки на неком носителе. Конечно, за счет dependency injection можно быстро и безболезненно задействовать иные типы хранилищ. А т.к. тип хранилища для уже существующих временных файлов мы знаем, можно даже совмещать одновременное использование разных типов хранилищ. При этом использование Puppeteer накладывает определенные ограничения: механизм работы библиотеки таков, что страницы должны открываться в хромиуме, т.е. нельзя подкинуть условный filestream, нужен конкретный путь/url.

В сервис добавлено использование ключа идемпотентности, чтобы не конвертировать одни и те же файлы в случае сетевых и прочих сбоев. Заодно он будет использоваться для получения статуса задачи (можно ли уже забрать pdf, или еще нет).

После того, как клиент получил результат, файл можно удалять из временного хранилища. Проблема в том, что мы не можем гарантированно узнать, что он получил. Мы даже не можем попросить сообщать нам о факте получения, это уже превратится в задачу о двух генералах. Потому очисткой временного хранилища должно заниматься отдельное приложение, или эта процедура должна выполняться в рамках общей регламентной процедуры по очистке, зависит от конкретной системы. Предполагается, что тем или иным способом оно будет запускаться по регламенту и, в соответствии с настройками, удалять то, что считается устаревшим и уже не нужным.

Задача могла бы потребовать разделение веб-сервиса на две части, чтобы отдельный сервис принимал результаты, а другой - возвращал. Но, на мой взгляд, данное разделение может быть избыточным, зависит от конкретных условий.
